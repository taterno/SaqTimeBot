from icecream import icfrom datetime import datetimefrom colorama import Fore, Styleimport reimport phonenumbersfrom phonenumbers import carrierimport randomfrom urllib.parse import urlparse#region PRIVATEdef custom_debugger(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.MAGENTA}{value}{Style.RESET_ALL}")def custom_debugger_debug(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.LIGHTGREEN_EX}{value}{Style.RESET_ALL}")def custom_debugger_error(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.RED}{value}{Style.RESET_ALL}")ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)#endregiondef log(logging, command='NULL'):    if command == 'DEBUG':        DEBUG = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_debug)        ic(DEBUG)    elif command == 'INFO':        INFO = logging        ic(INFO)    elif command == 'ERROR':        ERROR = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_error)        ic(ERROR)    else:        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)        ic(logging)def Refactor(inputStr, prefixes=['/'], slice = False):    inputStr = inputStr    while inputStr and inputStr[0] in prefixes:        inputStr = inputStr[1:]    if slice:        return inputStr.split()    else:        return inputStrdef validFIO(name):    pattern = re.compile(r'^[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+$', re.IGNORECASE)    return bool(pattern.match(name))def is_valid_phone_number(phone_number, valid='num'):    if valid == 'num':        try:            # Попытка парсинга номера телефона            parsed_number = phonenumbers.parse(phone_number, None)            # Проверка на действительность номера            return phonenumbers.is_valid_number(parsed_number)        except phonenumbers.phonenumberutil.NumberParseException:            return False    elif valid == 'carrier':        try:            parsed_number = phonenumbers.parse(phone_number, None)            if phonenumbers.is_valid_number(parsed_number):                return carrier.name_for_number(parsed_number, "en")            else:                return False        except phonenumbers.phonenumberutil.NumberParseException:            return Falsedef update_config(cfg, section, key, value):    if section not in cfg:        cfg.add_section(section)    cfg.set(section, key, value)    with open('config.ini', 'w') as configfile:        cfg.write(configfile)def delete_config(cfg, section, key):    if section in cfg and key in cfg[section]:        cfg.remove_option(section, key)        with open('config.ini', 'w') as configfile:            cfg.write(configfile)def getUserLink(user_id, nick):    return f'[{nick}](tg://user?id={user_id})'def getStringLink(link, txt):    return f'[{txt}]({link})'def GetUserId(text):    # Регулярное выражение для извлечения ID пользователя по упоминанию с @    pattern_username = r'@([a-zA-Z0-9_]+)'    # Регулярное выражение для извлечения ID пользователя по ссылке на аккаунт    pattern_link = r't\.me/([a-zA-Z0-9_]+)|telegram.me/([a-zA-Z0-9_]+)'    matches_username = re.findall(pattern_username, text)    matches_link = re.findall(pattern_link, text)    if matches_username:        # Вернуть первое найденное совпадение по упоминанию с @        return matches_username[0]    elif matches_link:        # Вернуть первое найденное совпадение по ссылке на аккаунт        for match in matches_link[0]:            if match:                return match    else:        # Если ID пользователя не найден, вернуть None        return None# Функция для отображения кнопок именdef display_names_buttons(client, message, page_num, data, ikb, ikm):    start_index = (page_num - 1) * 15    end_index = min(start_index + 15, len(data))    keyboard = []    for user in data[start_index:end_index]:        face = user['FIO']        user.pop('FIO')        callback = str(user['id'])        keyboard.append([ikb(face, callback_data=callback)])    pagination_buttons = []    if page_num > 1:        pagination_buttons.append(ikb("Предыдущая", callback_data=f"previous_{page_num}"))    pagination_buttons.append(ikb("Поиск", callback_data=f"Search_volunteers"))    if end_index < len(data):        pagination_buttons.append(ikb("Следующая", callback_data=f"next_{page_num}"))    keyboard.append(pagination_buttons)    reply_markup = ikm(keyboard)    message.reply_text("Список волонтеров", reply_markup=reply_markup)def SingleMsg(app, msg, ids=None, cmd='cycle', count=1, list_ids=None):    if cmd == 'cycle':        for i in range(count):            app.send_message(ids, msg)    elif cmd == 'spm':        for id in list_ids:            text = f"Админы:\n{msg}"            app.send_message(id, text)def check_string(input_string):    pattern = re.compile("^[a-zA-Zа-яА-Я]+$")    return bool(pattern.match(input_string))def check_geo_link(input_string):    pattern = r'(https?:\/\/)?(www\.)?(2gis\.kg|yandex\.ru|google\.com\/maps)\/'    if re.search(pattern, input_string):        return True    else:        return False# Извлечение чистой ссылки из строкиdef extract_clean_link(input_string):    matches = re.findall(r'(https?://\S+)', input_string)    if matches:        return urlparse(matches[0]).geturl()    else:        return Nonedef is_valid_time_format(time_str):    try:        datetime.strptime(time_str, '%H:%M')        return True    except ValueError:        return Falsedef chat_with_gpt(openai, translate, prompt):    def translate_en_to_ru(text):        if len(text) >= 300:            lst1 = text.split('.')            translated_text = ''            for i in lst1:                j = translate(i, 'ru', 'en')                translated_text += j + '.'        else:            translated_text = translate(text, 'ru', 'en')        return translated_text    def translate_ru_to_en(text):        translated_text = translate(text, 'en', 'ru')        return translated_text    try:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "user",                    "content": translate_ru_to_en(prompt)                }            ],            temperature=1,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        content = translate_en_to_ru(response['choices'][0]["message"]["content"])        return content    except:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "assistant",                    "content": prompt                }            ],            temperature=2,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        return translate_en_to_ru(response['choices'][0]["message"]["content"])def ChatGptSys(app, msg, openai, translate, cmd):    con = "Ответь по заданным настройкам сразу, тебя зовут SaqTimeBot, ты помощник в волонтерской компании, любишь помогать всем, теперь мое сообщение - \n".join(cmd[1:])    resp = chat_with_gpt(openai, translate, con)    msg.reply_text(resp)