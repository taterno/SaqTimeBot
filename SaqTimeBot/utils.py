from icecream import icfrom datetime import datetime, timedeltafrom colorama import Fore, Styleimport reimport phonenumbersfrom phonenumbers import carrierimport randomfrom urllib.parse import urlparse#region PRIVATEdef custom_debugger(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.MAGENTA}{value}{Style.RESET_ALL}")def custom_debugger_debug(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.LIGHTGREEN_EX}{value}{Style.RESET_ALL}")def custom_debugger_error(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.RED}{value}{Style.RESET_ALL}")ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)#endregiondef get_week_string(cmd=0):    today = datetime.today()    current_week_start = today - timedelta(days=today.weekday())    next_week_start = current_week_start + timedelta(days=7)    current_week_end = current_week_start + timedelta(days=6)    next_week_end = next_week_start + timedelta(days=6)    if cmd == 0:        current_week_string = f'{current_week_start.strftime("%d.%m")} - {current_week_end.strftime("%d.%m")}'        return current_week_string    elif cmd == 1:        next_week_string = f'{next_week_start.strftime("%d.%m")} - {next_week_end.strftime("%d.%m")}'        return next_week_stringdef send_message(app, id, text):        app.send_message(id, text)def log(logging, command='NULL'):    if command == 'DEBUG':        DEBUG = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_debug)        ic(DEBUG)    elif command == 'INFO':        INFO = logging        ic(INFO)    elif command == 'ERROR':        ERROR = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_error)        ic(ERROR)    else:        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)        ic(logging)def Refactor(inputStr, prefixes=['/'], slice = False):    inputStr = inputStr    while inputStr and inputStr[0] in prefixes:        inputStr = inputStr[1:]    if slice:        return inputStr.split(' ')    else:        return inputStrdef validFIO(name):    pattern = re.compile(r'^[–ê-–Ø–ÅA-Z][–∞-—è—ëA-Za-z]+\s[–ê-–Ø–ÅA-Z][–∞-—è—ëA-Za-z]+$', re.IGNORECASE)    return bool(pattern.match(name))def valid_birthdate(input_string):    try:        date = datetime.strptime(input_string, '%d.%m.%Y')        today = datetime.today()        age = today.year - date.year - ((today.month, today.day) < (date.month, date.day))        if 5 <= age <= 80 and date <= today:            return True        else:            return False    except ValueError:        return Falsedef valid_email(email):    # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–æ—Ä–º–∞—Ç–∞ email    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —Å –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º    if re.match(pattern, email):        return True    else:        return Falsedef valid_number(phone_number, valid='num'):    if valid == 'num':        try:            # –ü–æ–ø—ã—Ç–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞            parsed_number = phonenumbers.parse(phone_number, None)            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–∞            return phonenumbers.is_valid_number(parsed_number)        except phonenumbers.phonenumberutil.NumberParseException:            return False    elif valid == 'carrier':        try:            parsed_number = phonenumbers.parse(phone_number, None)            if phonenumbers.is_valid_number(parsed_number):                return carrier.name_for_number(parsed_number, "en")            else:                return False        except phonenumbers.phonenumberutil.NumberParseException:            return Falsedef update_config(cfg, section, key, value):    if section not in cfg:        cfg.add_section(section)    cfg.set(section, key, value)    with open('config.ini', 'w') as configfile:        cfg.write(configfile)def delete_config(cfg, section, key):    if section in cfg and key in cfg[section]:        cfg.remove_option(section, key)        with open('config.ini', 'w') as configfile:            cfg.write(configfile)def getUserLink(user_id, nick):    return f'[{nick}](tg://user?id={user_id})'def getStringLink(link, txt):    return f'[{txt}]({link})'def GetUserId(text):    # –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —É–ø–æ–º–∏–Ω–∞–Ω–∏—é —Å @    pattern_username = r'@([a-zA-Z0-9_]+)'    # –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç    pattern_link = r't\.me/([a-zA-Z0-9_]+)|telegram.me/([a-zA-Z0-9_]+)'    matches_username = re.findall(pattern_username, text)    matches_link = re.findall(pattern_link, text)    if matches_username:        # –í–µ—Ä–Ω—É—Ç—å –ø–µ—Ä–≤–æ–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ —É–ø–æ–º–∏–Ω–∞–Ω–∏—é —Å @        return matches_username[0]    elif matches_link:        # –í–µ—Ä–Ω—É—Ç—å –ø–µ—Ä–≤–æ–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç        for match in matches_link[0]:            if match:                return match    else:        # –ï—Å–ª–∏ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω, –≤–µ—Ä–Ω—É—Ç—å None        return Nonedef display_names_buttons(client, message, page_num, data, ikb, ikm):    start_index = (page_num - 1) * 15    end_index = min(start_index + 15, len(data))    keyboard = []    for user in data[start_index:end_index]:        face = user['FIO']        user.pop('FIO')        callback = str(user['id'])        keyboard.append([ikb(face, callback_data=callback)])    pagination_buttons = []    if page_num > 1:        pagination_buttons.append(ikb("–ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"previous_{page_num}"))    pagination_buttons.append(ikb("–ü–æ–∏—Å–∫", callback_data=f"Search_volunteers"))    if end_index < len(data):        pagination_buttons.append(ikb("–°–ª–µ–¥—É—é—â–∞—è", callback_data=f"next_{page_num}"))    keyboard.append(pagination_buttons)    reply_markup = ikm(keyboard)    message.reply_text("–°–ø–∏—Å–æ–∫ –≤–æ–ª–æ–Ω—Ç–µ—Ä–æ–≤", reply_markup=reply_markup)def SingleMsg(app, msg, ids=None, cmd='cycle', count=1, list_ids=None):    if cmd == 'cycle':        for i in range(count):            app.send_message(ids, msg)    elif cmd == 'spm':        for id in list_ids:            text = f"–ê–¥–º–∏–Ω—ã:\n{msg}"            app.send_message(id, text)def check_string(input_string):    pattern = re.compile("^[a-zA-Z–∞-—è–ê-–Ø]+$")    return bool(pattern.match(input_string))def check_geo_link(input_string):    pattern = r'(https?:\/\/)?(www\.)?(2gis\.kg|yandex\.ru|google\.com\/maps)\/'    if re.search(pattern, input_string):        return True    else:        return Falsedef parse_text(text):    entries = text.split('\n')    while '-' in entries:        entries.remove('-')    while '' in entries:        entries.remove('')    if entries:        if entries[0].startswith('—Ä–∞–π–æ–Ω '):            region = entries[0].lower().replace('—Ä–∞–π–æ–Ω ', '')            checkpoint = entries[1]            if len(region.encode('utf-8')) >= 20:                return '4'            entries = entries[2:]            locations = {}            c = 1            for i in range(0, len(entries), 3):                match = re.match(r'(.*)\((\d+)\)', entries[i])                if match:                    name = match.group(1).strip()                    count = int(match.group(2))                    locations[c] = {                        'name': name,                        'count': count,                        'comment': entries[i + 1],                        'person': entries[i + 2],                        'volunteers': []                    }                    c += 1                else:                    return '3'            data = {region: [locations, checkpoint]}            return data        else:            return '2'    else:        return '1'    return regionsdef parse_text_juma(text):    entries = text.split('\n')    while '-' in entries:        entries.remove('-')    while '' in entries:        entries.remove('')    if entries and len(entries) >= 3:        match = re.match(r'(.*)\((\d+)\)', entries[0])        if not match:            return '3'        name = match.group(1).strip()        count = int(match.group(2))        needy = entries[1]        if name and needy and entries:            if len(name.encode('utf-8')) >= 20:                return '4'            link = entries[2]            if len(entries) == 4:                comment = entries[3]            else:                comment = 'NULL'            data = {                    name:[{                        'count': count,                        'needy': needy,                        'link': link,                        'volunteers': []                    }, comment]                }            return data        else:            return '1'    else:        return '2'def parse_text_needy(text):    entries = text.split('\n')    while '' in entries:        entries.remove('')    if entries and len(entries) == 5:        match = re.match(r'(.*) (\d+)', entries[0])        match1 = re.match(r'(\d+) (\d+)', entries[3])        if not match:            return '1'        elif not match1:            return '2'        name = match.group(1).strip()        age = int(match.group(2))        clinic = entries[1]        diagnos = entries[2]        amount = int(match1.group(1))        left = int(match1.group(2))        if amount >= left:            date = entries[4]            collect = {'name': name,                      'age': age,                      'clinic': clinic,                      'amount': amount,                      'left': left,                      'date': date,                      'diagnosis': diagnos                       }            return collect        else:            return '4'    else:        return '3'def extract_clean_link(input_string):    matches = re.findall(r'(https?://\S+)', input_string)    if matches:        return urlparse(matches[0]).geturl()    else:        return Nonedef is_valid_time_format(time_str):    try:        datetime.strptime(time_str, '%H:%M')        return True    except ValueError:        return Falsedef calculate_age(birth_date_string, date_format='%d.%m.%Y'):    birth_date = datetime.strptime(birth_date_string, date_format)    today = datetime.today()    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))    return agedef chat_with_gpt(openai, translate, prompt):    def translate_en_to_ru(text):        if len(text) >= 300:            lst1 = text.split('.')            translated_text = ''            for i in lst1:                j = translate(i, 'ru', 'en')                translated_text += j + '.'        else:            translated_text = translate(text, 'ru', 'en')        return translated_text    def translate_ru_to_en(text):        translated_text = translate(text, 'en', 'ru')        return translated_text    try:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "user",                    "content": translate_ru_to_en(prompt)                }            ],            temperature=1,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        content = translate_en_to_ru(response['choices'][0]["message"]["content"])        return content    except:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "assistant",                    "content": prompt                }            ],            temperature=2,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        return translate_en_to_ru(response['choices'][0]["message"]["content"])def ChatGptSys(app, msg, openai, translate, cmd):    con = "–û—Ç–≤–µ—Ç—å –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º —Å—Ä–∞–∑—É, —Ç–µ–±—è –∑–æ–≤—É—Ç SaqTimeBot, —Ç—ã –ø–æ–º–æ—â–Ω–∏–∫ –≤ –≤–æ–ª–æ–Ω—Ç–µ—Ä—Å–∫–æ–π –∫–æ–º–ø–∞–Ω–∏–∏, –ª—é–±–∏—à—å –ø–æ–º–æ–≥–∞—Ç—å –≤—Å–µ–º\n"    con += "–ü—Ä–æ SaqTime, —Å–±–æ—Ä —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –Ω—É–∂–¥–∞—é—â–∏—Ö—Å—è —É –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ–ø–ª–∞—Ç–∏—Ç—å –ª–µ—á–µ–Ω–∏–µ —Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–π –±–æ–ª–µ–∑–Ω–∏, –æ—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —ç—Ç–æ–π —Ç–µ–º–æ–π, –∏–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–ª—è–π —Å–ª–æ–≤–æ '–Ω–µ—Ç'"    con += "–º–æ–π –≤–æ–ø—Ä–æ—Å:\n"    con += cmd    resp = chat_with_gpt(openai, translate, con)    return respdef generate_date_list(input_string):    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –≤—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–æ–¥ —à–∞–±–ª–æ–Ω    try:        start_date_str, end_date_str = input_string.split(" - ")        datetime.strptime(start_date_str, "%d.%m")        datetime.strptime(end_date_str, "%d.%m")    except ValueError:        return False    # –†–∞–∑–±–∏–≤–∞–µ–º –≤—Ö–æ–¥–Ω—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—ã    start_date = datetime.strptime(start_date_str, "%d.%m")    end_date = datetime.strptime(end_date_str, "%d.%m")    # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–∞—Ç    date_list = []    current_date = start_date    while current_date <= end_date:        date_list.append(current_date.strftime("%d.%m"))        current_date += timedelta(days=1)    if len(date_list) < 7:        return '–ú–µ–Ω—å—à–µ'    elif len(date_list) > 7:        return '–ë–æ–ª—å—à–µ'    else:        return date_listdef get_weekday(date_string):    day, month = map(int, date_string.split('.'))    year = datetime.now().year    date_formatted = datetime(year, month, day)    weekdays = ['–ü–ù', '–í–¢', '–°–†', '–ß–¢', '–ü–¢', '–°–ë', '–í–°']    return weekdays[date_formatted.weekday()]def merge_dicts(data2, data1):    result = {}    for key, value in data1.items():        if key in result:            result[key].update(value)        else:            result[key] = value    for key, value in data2.items():        if key in result:            result[key].update(value)        else:            result[key] = value    return resultdef get_this_week():    days_of_week_russian = {        0: "–ü–ù",        1: "–í–¢",        2: "–°–†",        3: "–ß–¢",        4: "–ü–¢",        5: "–°–ë",        6: "–í–°"    }    today = datetime.now()    start_of_next_week = today + timedelta(days=(7 - today.weekday()))  # –∏–∑–º–µ–Ω–µ–Ω–æ    days_of_next_week = [start_of_next_week + timedelta(days=i) for i in range(7)]    return [f"{day.strftime('%d.%m')}-{days_of_week_russian[day.weekday()]}" for day in days_of_next_week]def get_next_week():    days_of_week_russian = {        0: "–ü–ù",        1: "–í–¢",        2: "–°–†",        3: "–ß–¢",        4: "–ü–¢",        5: "–°–ë",        6: "–í–°"    }    today = datetime.now()    start_of_next_week = today + timedelta(days=(14 - today.weekday()))  # –∏–∑–º–µ–Ω–µ–Ω–æ    days_of_next_week = [start_of_next_week + timedelta(days=i) for i in range(7)]    return [f"{day.strftime('%d.%m')}-{days_of_week_russian[day.weekday()]}" for day in days_of_next_week]def get_closest_dates(date_strings):    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫ –≤ –æ–±—ä–µ–∫—Ç—ã –¥–∞—Ç    date_objects = [datetime.strptime(date, "%d.%m") for date in date_strings]    # –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞    today = datetime.now()    # –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –∫–∞–∂–¥–æ–π –¥–∞—Ç–æ–π –∏ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π    differences = [abs(date - today) for date in date_objects]    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–∞—Ç –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é —Ä–∞–∑–Ω–∏—Ü—ã    sorted_dates = [date for _, date in sorted(zip(differences, date_objects))]    # –í–∑—è—Ç—å –ø–µ—Ä–≤—ã–µ –¥–≤–µ –¥–∞—Ç—ã    closest_dates = sorted_dates[:2]    return closest_datesdef get_closest_dates_str(date_strings):    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫ –≤ –æ–±—ä–µ–∫—Ç—ã –¥–∞—Ç    date_objects = [datetime.strptime(date, "%d.%m") for date in date_strings]    # –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞    today = datetime.now()    # –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –∫–∞–∂–¥–æ–π –¥–∞—Ç–æ–π –∏ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π    differences = [abs(date - today) for date in date_objects]    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–∞—Ç –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é —Ä–∞–∑–Ω–∏—Ü—ã    sorted_dates = [date for _, date in sorted(zip(differences, date_objects))]    # –í–∑—è—Ç—å –ø–µ—Ä–≤—ã–µ –¥–≤–µ –¥–∞—Ç—ã –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∏—Ö –æ–±—Ä–∞—Ç–Ω–æ –≤ —Å—Ç—Ä–æ–∫–∏    closest_dates = [date.strftime("%d.%m") for date in sorted_dates[:2]]    return closest_datesdef format_dates(date_strings):    formatted_dates = []    for date_str in date_strings:        try:            if date_str.strip():                date_obj = datetime.strptime(date_str, "%d.%m")        except AttributeError:            date_obj = date_str        # –î–æ–±–∞–≤–∏—Ç—å 6 –¥–Ω–µ–π –∫ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–µ        date_plus_six_days = date_obj + timedelta(days=6)        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ –º–µ—Å—è—Ü–∞        if date_plus_six_days.month != date_obj.month:            # –ï—Å–ª–∏ –º–µ—Å—è—Ü –∏–∑–º–µ–Ω–∏–ª—Å—è, —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–∞—Ç—É –Ω–∞ –∫–æ–Ω–µ—Ü —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞ –∏ –¥–æ–±–∞–≤–∏—Ç—å 6 –¥–Ω–µ–π            end_of_current_month = datetime(date_obj.year, date_obj.month, 1) + timedelta(days=32)            date_plus_six_days = min(date_plus_six_days, end_of_current_month)        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É        formatted_date = f"{date_obj.day:02d}.{date_obj.month:02d} - {date_plus_six_days.day:02d}.{date_plus_six_days.month:02d}"        formatted_dates.append(formatted_date)    return formatted_datesdef find_nearest_date(dates_list):    days_of_week_russian = {        0: "–ü–ù",        1: "–í–¢",        2: "–°–†",        3: "–ß–¢",        4: "–ü–¢",        5: "–°–ë",        6: "–í–°"    }    # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞—Ç—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏    def parse_date(date_str):        day, month_weekday = date_str.split('.')        month, weekday = month_weekday.split('-')        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç datetime        date = datetime(year=2023, month=int(month), day=int(day))        return date    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –æ–±—ä–µ–∫—Ç—ã datetime    parsed_dates = [parse_date(date_str) for date_str in dates_list]    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É    current_date = datetime.now()    # –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é –¥–∞—Ç—É    nearest_date = min(parsed_dates, key=lambda date: abs(date - current_date))    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –±–ª–∏–∂–∞–π—à—É—é –¥–∞—Ç—É    nearest_date_str = f"{nearest_date.day}.{nearest_date.month:02d}-{days_of_week_russian[nearest_date.weekday()]}"    return nearest_date_strdef find_farthest_date(dates_list):    days_of_week_russian = {        0: "–ü–ù",        1: "–í–¢",        2: "–°–†",        3: "–ß–¢",        4: "–ü–¢",        5: "–°–ë",        6: "–í–°"    }    # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞—Ç—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏    def parse_date(date_str):        day, month_weekday = date_str.split('.')        month, weekday = month_weekday.split('-')        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç datetime        date = datetime(year=2023, month=int(month), day=int(day))        return date    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ –æ–±—ä–µ–∫—Ç—ã datetime    parsed_dates = [parse_date(date_str) for date_str in dates_list]    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É    current_date = datetime.now()    # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—É—é –¥–∞–ª—å–Ω—é—é –¥–∞—Ç—É    farthest_date = max(parsed_dates, key=lambda date: abs(date - current_date))    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∞–º—É—é –¥–∞–ª—å–Ω—é—é –¥–∞—Ç—É    farthest_date_str = f"{farthest_date.day}.{farthest_date.month:02d}-{days_of_week_russian[farthest_date.weekday()]}"    return farthest_date_strdef get_date_and_weekday(input_date):    # –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å–ª–æ–≤–∞—Ä—å –¥–Ω–µ–π –Ω–µ–¥–µ–ª–∏    days_of_week_russian = {        0: "–ü–ù",        1: "–í–¢",        2: "–°–†",        3: "–ß–¢",        4: "–ü–¢",        5: "–°–ë",        6: "–í–°"    }    # –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∏ —Å–∏–º–≤–æ–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "-–°–†")    input_date = input_date[:-3]    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤—Ö–æ–¥–Ω—É—é —Å—Ç—Ä–æ–∫—É –≤ –æ–±—ä–µ–∫—Ç datetime    format_str = "%d.%m"    date_obj = datetime.strptime(input_date, format_str)    # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏ (0 - –ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫, 1 - –í—Ç–æ—Ä–Ω–∏–∫ –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ)    weekday_num = date_obj.weekday()    # –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—É –¥–Ω—è –Ω–µ–¥–µ–ª–∏ –∏–∑ —Å–ª–æ–≤–∞—Ä—è    weekday = days_of_week_russian.get(weekday_num, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏")    # –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç    result = f"{date_obj.day}.{date_obj.month}-{weekday}"    return resultdef shot_dateline(schedule):    txt = ''    def append_to_txt(data):        nonlocal txt        txt += data + '\n'    for date, locations in schedule.items():        append_to_txt(f'{date}:')        for location, events in locations.items():            append_to_txt(f'  {location}:')            for place, details in events.items():                append_to_txt(f'    {place}:')                if isinstance(details, list):                    for entry in details:                        if isinstance(entry, dict):                            for key, value in entry.items():                                append_to_txt(f'      {key}: {value}')                        else:                            append_to_txt(f'      {entry}')                elif isinstance(details, dict):                    for item, data in details.items():                        if isinstance(data, list):                            append_to_txt(f'      {item}:')                            for entry in data:                                if isinstance(entry, dict):                                    for key, value in entry.items():                                        append_to_txt(f'        {key}: {value}')                                else:                                    append_to_txt(f'        {entry}')                        elif isinstance(data, dict):                            append_to_txt(f'      {item}:')                            for key, value in data.items():                                append_to_txt(f'        {key}: {value}')                        else:                            append_to_txt(f'      {item}: {data}')                else:                    append_to_txt(f'    {place}: {details}')    return txtdef get_max_date(date_list, m = False):    ref_dates = []    for date in date_list:        ref_dates.append(date.replace('-–ü–ù', ''))    sault = {        1: 31,        2: 28,        3: 30,        4: 31,        5: 30,        6: 31,        7: 30,        8: 31,        9: 30,        10: 31,        11: 30,        12: 31,    }    res = []    for el in ref_dates:        x, y = el.split('.')        sum = int(x) + int(y) * sault[int(y)]        res.append(sum)    if m:        index = date_list[res.index(min(res))]    else:        index = date_list[res.index(max(res))]    return indexdef get_info():    return """SaqTime - —ç—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –≤–æ–ª–æ–Ω—Ç–µ—Ä—Å–∫–∞—è –∫–æ–º–ø–∞–Ω–∏—è, –∞ —Ü–µ–ª–æ–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–æ–º—ã—à–ª–µ–Ω–Ω–∏–∫–æ–≤, –≥–¥–µ –∫–∞–∂–¥—ã–π –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å —á–∞—Å—Ç—å—é —á–µ–≥–æ-—Ç–æ –≤–∞–∂–Ω–æ–≥–æ. –ù–∞—à–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, —Å–æ–∑–≤—É—á–Ω–æ–µ —Å –∫—ã—Ä–≥—ã–∑—Å–∫–∏–º —Å–ª–æ–≤–æ–º "—Å–∞–∫—Ç–∞–π–º" (—á—Ç–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—Å—è –∫–∞–∫ "–Ø –±—É–¥—É —Å–ø–∞—Å–∞—Ç—å!"), –æ—Ç—Ä–∞–∂–∞–µ—Ç –Ω–∞—à–µ —Å—Ç—Ä–µ–º–ª–µ–Ω–∏–µ –∫ —Å–æ–∑–∏–¥–∞–Ω–∏—é, –ø–æ–¥–¥–µ—Ä–∂–∫–µ –∏ –ø–æ–º–æ—â–∏.–ú—ã - –ø—Ä–æ—Å–≤—è—Ç–∞—é—â–∞—è –∫–æ–º–ø–∞–Ω–∏—è, –≥–¥–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –ø—Ä–∏–Ω–æ—Å–∏—Ç –Ω–æ–≤—ã–µ –∑–Ω–∞–Ω–∏—è, –æ–ø—ã—Ç –∏ —Ä–∞–¥–æ—Å—Ç—å –≤ –Ω–∞—à –∫–æ–ª–ª–µ–∫—Ç–∏–≤. –ù–∞—à–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç–æ –∏ –≥–æ—Å—Ç–µ–ø—Ä–∏–∏–º–Ω–æ –¥–ª—è –≤—Å–µ—Ö, –∫—Ç–æ —Ä–∞–∑–¥–µ–ª—è–µ—Ç –Ω–∞—à–∏ —Ü–µ–Ω–Ω–æ—Å—Ç–∏ –∏ —Å—Ç—Ä–µ–º–∏—Ç—Å—è –¥–µ–ª–∞—Ç—å –º–∏—Ä –ª—É—á—à–µ.–£ –Ω–∞—Å –≤—Å–µ–≥–¥–∞ —Ä–∞–¥—ã –Ω–æ–≤–∏—á–∫–∞–º! –ó–¥–µ—Å—å –≤—ã –Ω–∞–π–¥–µ—Ç–µ –Ω–µ —Ç–æ–ª—å–∫–æ –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏–µ, –Ω–æ –∏ –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ, –≥–¥–µ –∫–∞–∂–¥—ã–π –≤–Ω–æ—Å–∏—Ç —Å–≤–æ–π –≤–∫–ª–∞–¥ –≤ –Ω–∞—à—É –æ–±—â—É—é –º–∏—Å—Å–∏—é. –ú—ã –≤–µ—Ä–∏–º, —á—Ç–æ –≤–º–µ—Å—Ç–µ –º—ã —Å–∏–ª–∞, —Å–ø–æ—Å–æ–±–Ω–∞—è –∏–∑–º–µ–Ω–∏—Ç—å –º–∏—Ä –∫ –ª—É—á—à–µ–º—É.–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ SaqTime –∏ —Å—Ç–∞–Ω—å—Ç–µ —á–∞—Å—Ç—å—é —á–µ–≥–æ-—Ç–æ –±–æ–ª—å—à–µ–≥–æ. –í–º–µ—Å—Ç–µ –º—ã –±—É–¥–µ–º —Å–ø–∞—Å–∞—Ç—å, –≤–º–µ—Å—Ç–µ –º—ã –±—É–¥–µ–º —Å—Ç—Ä–æ–∏—Ç—å —Å–≤–µ—Ç–ª–æ–µ –±—É–¥—É—â–µ–µ! üíô‚ú®    """def GWA():    week_abbreviations = {        1: '–ü–ù',        2: '–í–¢',        3: '–°–†',        4: '–ß–¢',        5: '–ü–¢',        6: '–°–ë',        7: '–í–°'    }    return week_abbreviations