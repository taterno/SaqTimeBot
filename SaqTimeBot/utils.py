from icecream import icfrom datetime import datetime, timedeltafrom colorama import Fore, Styleimport reimport phonenumbersfrom phonenumbers import carrierimport randomfrom urllib.parse import urlparse#region PRIVATEdef custom_debugger(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.MAGENTA}{value}{Style.RESET_ALL}")def custom_debugger_debug(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.LIGHTGREEN_EX}{value}{Style.RESET_ALL}")def custom_debugger_error(value):    current_time = datetime.now().strftime("%H:%M:%S")    print(f"{Fore.CYAN}{current_time} - {Fore.RED}{value}{Style.RESET_ALL}")ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)#endregiondef get_week_string(cmd=0):    today = datetime.today()    current_week_start = today - timedelta(days=today.weekday())    next_week_start = current_week_start + timedelta(days=7)    current_week_end = current_week_start + timedelta(days=6)    next_week_end = next_week_start + timedelta(days=6)    if cmd == 0:        current_week_string = f'{current_week_start.strftime("%d.%m")} - {current_week_end.strftime("%d.%m")}'        return current_week_string    elif cmd == 1:        next_week_string = f'{next_week_start.strftime("%d.%m")} - {next_week_end.strftime("%d.%m")}'        return next_week_stringdef send_message(app, id, text):        app.send_message(id, text)def log(logging, command='NULL'):    if command == 'DEBUG':        DEBUG = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_debug)        ic(DEBUG)    elif command == 'INFO':        INFO = logging        ic(INFO)    elif command == 'ERROR':        ERROR = logging        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger_error)        ic(ERROR)    else:        ic.configureOutput(prefix="", includeContext=False, outputFunction=custom_debugger)        ic(logging)def Refactor(inputStr, prefixes=['/'], slice = False):    inputStr = inputStr    while inputStr and inputStr[0] in prefixes:        inputStr = inputStr[1:]    if slice:        return inputStr.split(' ')    else:        return inputStrdef validFIO(name):    pattern = re.compile(r'^[А-ЯЁA-Z][а-яёA-Za-z]+\s[А-ЯЁA-Z][а-яёA-Za-z]+$', re.IGNORECASE)    return bool(pattern.match(name))def valid_birthdate(input_string):    try:        date = datetime.strptime(input_string, '%d.%m.%Y')        today = datetime.today()        age = today.year - date.year - ((today.month, today.day) < (date.month, date.day))        if 5 <= age <= 80 and date <= today:            return True        else:            return False    except ValueError:        return Falsedef valid_email(email):    # Паттерн для проверки формата email    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"    # Проверка совпадения с паттерном    if re.match(pattern, email):        return True    else:        return Falsedef valid_number(phone_number, valid='num'):    if valid == 'num':        try:            # Попытка парсинга номера телефона            parsed_number = phonenumbers.parse(phone_number, None)            # Проверка на действительность номера            return phonenumbers.is_valid_number(parsed_number)        except phonenumbers.phonenumberutil.NumberParseException:            return False    elif valid == 'carrier':        try:            parsed_number = phonenumbers.parse(phone_number, None)            if phonenumbers.is_valid_number(parsed_number):                return carrier.name_for_number(parsed_number, "en")            else:                return False        except phonenumbers.phonenumberutil.NumberParseException:            return Falsedef update_config(cfg, section, key, value):    if section not in cfg:        cfg.add_section(section)    cfg.set(section, key, value)    with open('config.ini', 'w') as configfile:        cfg.write(configfile)def delete_config(cfg, section, key):    if section in cfg and key in cfg[section]:        cfg.remove_option(section, key)        with open('config.ini', 'w') as configfile:            cfg.write(configfile)def getUserLink(user_id, nick):    return f'[{nick}](tg://user?id={user_id})'def getStringLink(link, txt):    return f'[{txt}]({link})'def GetUserId(text):    # Регулярное выражение для извлечения ID пользователя по упоминанию с @    pattern_username = r'@([a-zA-Z0-9_]+)'    # Регулярное выражение для извлечения ID пользователя по ссылке на аккаунт    pattern_link = r't\.me/([a-zA-Z0-9_]+)|telegram.me/([a-zA-Z0-9_]+)'    matches_username = re.findall(pattern_username, text)    matches_link = re.findall(pattern_link, text)    if matches_username:        # Вернуть первое найденное совпадение по упоминанию с @        return matches_username[0]    elif matches_link:        # Вернуть первое найденное совпадение по ссылке на аккаунт        for match in matches_link[0]:            if match:                return match    else:        # Если ID пользователя не найден, вернуть None        return Nonedef display_names_buttons(client, message, page_num, data, ikb, ikm):    start_index = (page_num - 1) * 15    end_index = min(start_index + 15, len(data))    keyboard = []    for user in data[start_index:end_index]:        face = user['FIO']        user.pop('FIO')        callback = str(user['id'])        keyboard.append([ikb(face, callback_data=callback)])    pagination_buttons = []    if page_num > 1:        pagination_buttons.append(ikb("Предыдущая", callback_data=f"previous_{page_num}"))    pagination_buttons.append(ikb("Поиск", callback_data=f"Search_volunteers"))    if end_index < len(data):        pagination_buttons.append(ikb("Следующая", callback_data=f"next_{page_num}"))    keyboard.append(pagination_buttons)    reply_markup = ikm(keyboard)    message.reply_text("Список волонтеров", reply_markup=reply_markup)def SingleMsg(app, msg, ids=None, cmd='cycle', count=1, list_ids=None):    if cmd == 'cycle':        for i in range(count):            app.send_message(ids, msg)    elif cmd == 'spm':        for id in list_ids:            text = f"Админы:\n{msg}"            app.send_message(id, text)def check_string(input_string):    pattern = re.compile("^[a-zA-Zа-яА-Я]+$")    return bool(pattern.match(input_string))def check_geo_link(input_string):    pattern = r'(https?:\/\/)?(www\.)?(2gis\.kg|yandex\.ru|google\.com\/maps)\/'    if re.search(pattern, input_string):        return True    else:        return Falsedef parse_text(text):    entries = text.split('\n')    while '-' in entries:        entries.remove('-')    while '' in entries:        entries.remove('')    if entries:        if entries[0].startswith('район '):            region = entries[0].lower().replace('район ', '')            checkpoint = entries[1]            if len(region.encode('utf-8')) >= 20:                return '4'            entries = entries[2:]            locations = {}            c = 1            for i in range(0, len(entries), 3):                match = re.match(r'(.*)\((\d+)\)', entries[i])                if match:                    name = match.group(1).strip()                    count = int(match.group(2))                    locations[c] = {                        'name': name,                        'count': count,                        'comment': entries[i + 1],                        'person': entries[i + 2],                        'volunteers': []                    }                    c += 1                else:                    return '3'            data = {region: [locations, checkpoint]}            return data        else:            return '2'    else:        return '1'    return regionsdef parse_text_juma(text):    entries = text.split('\n')    while '-' in entries:        entries.remove('-')    while '' in entries:        entries.remove('')    if entries and len(entries) >= 3:        match = re.match(r'(.*)\((\d+)\)', entries[0])        if not match:            return '3'        name = match.group(1).strip()        count = int(match.group(2))        needy = entries[1]        if name and needy and entries:            if len(name.encode('utf-8')) >= 20:                return '4'            link = entries[2]            if len(entries) == 4:                comment = entries[3]            else:                comment = 'NULL'            data = {                    name:[{                        'count': count,                        'needy': needy,                        'link': link,                        'volunteers': []                    }, comment]                }            return data        else:            return '1'    else:        return '2'def parse_text_needy(text):    entries = text.split('\n')    while '' in entries:        entries.remove('')    if entries and len(entries) == 5:        match = re.match(r'(.*) (\d+)', entries[0])        match1 = re.match(r'(\d+) (\d+)', entries[3])        if not match:            return '1'        elif not match1:            return '2'        name = match.group(1).strip()        age = int(match.group(2))        clinic = entries[1]        diagnos = entries[2]        amount = int(match1.group(1))        left = int(match1.group(2))        if amount >= left:            date = entries[4]            collect = {'name': name,                      'age': age,                      'clinic': clinic,                      'amount': amount,                      'left': left,                      'date': date,                      'diagnosis': diagnos                       }            return collect        else:            return '4'    else:        return '3'def extract_clean_link(input_string):    matches = re.findall(r'(https?://\S+)', input_string)    if matches:        return urlparse(matches[0]).geturl()    else:        return Nonedef is_valid_time_format(time_str):    try:        datetime.strptime(time_str, '%H:%M')        return True    except ValueError:        return Falsedef calculate_age(birth_date_string, date_format='%d.%m.%Y'):    birth_date = datetime.strptime(birth_date_string, date_format)    today = datetime.today()    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))    return agedef chat_with_gpt(openai, translate, prompt):    def translate_en_to_ru(text):        if len(text) >= 300:            lst1 = text.split('.')            translated_text = ''            for i in lst1:                j = translate(i, 'ru', 'en')                translated_text += j + '.'        else:            translated_text = translate(text, 'ru', 'en')        return translated_text    def translate_ru_to_en(text):        translated_text = translate(text, 'en', 'ru')        return translated_text    try:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "user",                    "content": translate_ru_to_en(prompt)                }            ],            temperature=1,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        content = translate_en_to_ru(response['choices'][0]["message"]["content"])        return content    except:        response = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {                    "role": "assistant",                    "content": prompt                }            ],            temperature=2,            max_tokens=100,            top_p=1,            frequency_penalty=0,            presence_penalty=0        )        return translate_en_to_ru(response['choices'][0]["message"]["content"])def ChatGptSys(app, msg, openai, translate, cmd):    con = "Ответь по заданным настройкам сразу, тебя зовут SaqTimeBot, ты помощник в волонтерской компании, любишь помогать всем\n"    con += "Про SaqTime, сбор средств для нуждающихся у которых нет возможности оплатить лечение смертельной болезни, отвечай только на вопросы связанные с этой темой, иначе отправляй слово 'нет'"    con += "мой вопрос:\n"    con += cmd    resp = chat_with_gpt(openai, translate, con)    return respdef generate_date_list(input_string):    # Проверяем, подходит ли входная строка под шаблон    try:        start_date_str, end_date_str = input_string.split(" - ")        datetime.strptime(start_date_str, "%d.%m")        datetime.strptime(end_date_str, "%d.%m")    except ValueError:        return False    # Разбиваем входную строку на начальную и конечную даты    start_date = datetime.strptime(start_date_str, "%d.%m")    end_date = datetime.strptime(end_date_str, "%d.%m")    # Создаем список дат    date_list = []    current_date = start_date    while current_date <= end_date:        date_list.append(current_date.strftime("%d.%m"))        current_date += timedelta(days=1)    if len(date_list) < 7:        return 'Меньше'    elif len(date_list) > 7:        return 'Больше'    else:        return date_listdef get_weekday(date_string):    day, month = map(int, date_string.split('.'))    year = datetime.now().year    date_formatted = datetime(year, month, day)    weekdays = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ', 'ВС']    return weekdays[date_formatted.weekday()]def merge_dicts(data2, data1):    result = {}    for key, value in data1.items():        if key in result:            result[key].update(value)        else:            result[key] = value    for key, value in data2.items():        if key in result:            result[key].update(value)        else:            result[key] = value    return resultdef get_this_week():    days_of_week_russian = {        0: "ПН",        1: "ВТ",        2: "СР",        3: "ЧТ",        4: "ПТ",        5: "СБ",        6: "ВС"    }    today = datetime.now()    start_of_next_week = today + timedelta(days=(7 - today.weekday()))  # изменено    days_of_next_week = [start_of_next_week + timedelta(days=i) for i in range(7)]    return [f"{day.strftime('%d.%m')}-{days_of_week_russian[day.weekday()]}" for day in days_of_next_week]def get_next_week():    days_of_week_russian = {        0: "ПН",        1: "ВТ",        2: "СР",        3: "ЧТ",        4: "ПТ",        5: "СБ",        6: "ВС"    }    today = datetime.now()    start_of_next_week = today + timedelta(days=(14 - today.weekday()))  # изменено    days_of_next_week = [start_of_next_week + timedelta(days=i) for i in range(7)]    return [f"{day.strftime('%d.%m')}-{days_of_week_russian[day.weekday()]}" for day in days_of_next_week]def get_closest_dates(date_strings):    # Преобразование строк в объекты дат    date_objects = [datetime.strptime(date, "%d.%m") for date in date_strings]    # Текущая дата    today = datetime.now()    # Разница между каждой датой и текущей датой    differences = [abs(date - today) for date in date_objects]    # Сортировка дат по возрастанию разницы    sorted_dates = [date for _, date in sorted(zip(differences, date_objects))]    # Взять первые две даты    closest_dates = sorted_dates[:2]    return closest_datesdef get_closest_dates_str(date_strings):    # Преобразование строк в объекты дат    date_objects = [datetime.strptime(date, "%d.%m") for date in date_strings]    # Текущая дата    today = datetime.now()    # Разница между каждой датой и текущей датой    differences = [abs(date - today) for date in date_objects]    # Сортировка дат по возрастанию разницы    sorted_dates = [date for _, date in sorted(zip(differences, date_objects))]    # Взять первые две даты и преобразовать их обратно в строки    closest_dates = [date.strftime("%d.%m") for date in sorted_dates[:2]]    return closest_datesdef format_dates(date_strings):    formatted_dates = []    for date_str in date_strings:        try:            if date_str.strip():                date_obj = datetime.strptime(date_str, "%d.%m")        except AttributeError:            date_obj = date_str        # Добавить 6 дней к текущей дате        date_plus_six_days = date_obj + timedelta(days=6)        # Проверка для коррекции месяца        if date_plus_six_days.month != date_obj.month:            # Если месяц изменился, установить дату на конец текущего месяца и добавить 6 дней            end_of_current_month = datetime(date_obj.year, date_obj.month, 1) + timedelta(days=32)            date_plus_six_days = min(date_plus_six_days, end_of_current_month)        # Форматировать даты в строку        formatted_date = f"{date_obj.day:02d}.{date_obj.month:02d} - {date_plus_six_days.day:02d}.{date_plus_six_days.month:02d}"        formatted_dates.append(formatted_date)    return formatted_datesdef find_nearest_date(dates_list):    days_of_week_russian = {        0: "ПН",        1: "ВТ",        2: "СР",        3: "ЧТ",        4: "ПТ",        5: "СБ",        6: "ВС"    }    # Функция для получения даты из строки    def parse_date(date_str):        day, month_weekday = date_str.split('.')        month, weekday = month_weekday.split('-')        # Создаем объект datetime        date = datetime(year=2023, month=int(month), day=int(day))        return date    # Преобразуем строки в объекты datetime    parsed_dates = [parse_date(date_str) for date_str in dates_list]    # Получаем текущую дату    current_date = datetime.now()    # Находим ближайшую дату    nearest_date = min(parsed_dates, key=lambda date: abs(date - current_date))    # Форматируем ближайшую дату    nearest_date_str = f"{nearest_date.day}.{nearest_date.month:02d}-{days_of_week_russian[nearest_date.weekday()]}"    return nearest_date_strdef find_farthest_date(dates_list):    days_of_week_russian = {        0: "ПН",        1: "ВТ",        2: "СР",        3: "ЧТ",        4: "ПТ",        5: "СБ",        6: "ВС"    }    # Функция для получения даты из строки    def parse_date(date_str):        day, month_weekday = date_str.split('.')        month, weekday = month_weekday.split('-')        # Создаем объект datetime        date = datetime(year=2023, month=int(month), day=int(day))        return date    # Преобразуем строки в объекты datetime    parsed_dates = [parse_date(date_str) for date_str in dates_list]    # Получаем текущую дату    current_date = datetime.now()    # Находим самую дальнюю дату    farthest_date = max(parsed_dates, key=lambda date: abs(date - current_date))    # Форматируем самую дальнюю дату    farthest_date_str = f"{farthest_date.day}.{farthest_date.month:02d}-{days_of_week_russian[farthest_date.weekday()]}"    return farthest_date_strdef get_date_and_weekday(input_date):    # Внутренний словарь дней недели    days_of_week_russian = {        0: "ПН",        1: "ВТ",        2: "СР",        3: "ЧТ",        4: "ПТ",        5: "СБ",        6: "ВС"    }    # Удалить последние три символа (например, "-СР")    input_date = input_date[:-3]    # Преобразовать входную строку в объект datetime    format_str = "%d.%m"    date_obj = datetime.strptime(input_date, format_str)    # Определить день недели (0 - Понедельник, 1 - Вторник и так далее)    weekday_num = date_obj.weekday()    # Получить соответствующую аббревиатуру дня недели из словаря    weekday = days_of_week_russian.get(weekday_num, "Некорректный день недели")    # Сформировать результат    result = f"{date_obj.day}.{date_obj.month}-{weekday}"    return resultdef shot_dateline(schedule):    txt = ''    def append_to_txt(data):        nonlocal txt        txt += data + '\n'    for date, locations in schedule.items():        append_to_txt(f'{date}:')        for location, events in locations.items():            append_to_txt(f'  {location}:')            for place, details in events.items():                append_to_txt(f'    {place}:')                if isinstance(details, list):                    for entry in details:                        if isinstance(entry, dict):                            for key, value in entry.items():                                append_to_txt(f'      {key}: {value}')                        else:                            append_to_txt(f'      {entry}')                elif isinstance(details, dict):                    for item, data in details.items():                        if isinstance(data, list):                            append_to_txt(f'      {item}:')                            for entry in data:                                if isinstance(entry, dict):                                    for key, value in entry.items():                                        append_to_txt(f'        {key}: {value}')                                else:                                    append_to_txt(f'        {entry}')                        elif isinstance(data, dict):                            append_to_txt(f'      {item}:')                            for key, value in data.items():                                append_to_txt(f'        {key}: {value}')                        else:                            append_to_txt(f'      {item}: {data}')                else:                    append_to_txt(f'    {place}: {details}')    return txtdef get_max_date(date_list, m = False):    ref_dates = []    for date in date_list:        ref_dates.append(date.replace('-ПН', ''))    sault = {        1: 31,        2: 28,        3: 30,        4: 31,        5: 30,        6: 31,        7: 30,        8: 31,        9: 30,        10: 31,        11: 30,        12: 31,    }    res = []    for el in ref_dates:        x, y = el.split('.')        sum = int(x) + int(y) * sault[int(y)]        res.append(sum)    if m:        index = date_list[res.index(min(res))]    else:        index = date_list[res.index(max(res))]    return indexdef get_info():    return """SaqTime - это не просто волонтерская компания, а целое сообщество единомышленников, где каждый может стать частью чего-то важного. Наше название, созвучное с кыргызским словом "сактайм" (что переводится как "Я буду спасать!"), отражает наше стремление к созиданию, поддержке и помощи.Мы - просвятающая компания, где каждый день приносит новые знания, опыт и радость в наш коллектив. Наше сообщество открыто и гостеприимно для всех, кто разделяет наши ценности и стремится делать мир лучше.У нас всегда рады новичкам! Здесь вы найдете не только вдохновение, но и комфортное сообщество, где каждый вносит свой вклад в нашу общую миссию. Мы верим, что вместе мы сила, способная изменить мир к лучшему.Присоединяйтесь к SaqTime и станьте частью чего-то большего. Вместе мы будем спасать, вместе мы будем строить светлое будущее! 💙✨    """def GWA():    week_abbreviations = {        1: 'ПН',        2: 'ВТ',        3: 'СР',        4: 'ЧТ',        5: 'ПТ',        6: 'СБ',        7: 'ВС'    }    return week_abbreviations